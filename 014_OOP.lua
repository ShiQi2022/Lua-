---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 86176.
--- DateTime: 2022/12/10 15:15
---

-- 面向对象
-- 面向对象和类其实都是基于 table 来实现的

-- 面向对象 封装
Object = {};
Object.Type = "Class";
function Object:Test()
    print(self.Type);
end

-- 冒号是自动调用这个函数的对象，作为第一个参数传入的写法
function Object:CreateClass()
    local obj = {};
    -- self 代表的是默认传入的第一个参数
    -- 对象就是变量，返回一个新的变量
    -- 返回出去的内容本质上就是表对象
    self.__index = self;
    -- __index 当找自己的变量，找不到时就会去元表中找 __index 指向的内容
    setmetatable(obj, self);
    return obj;
end
local object = Object:CreateClass();
object:Test();
print(object.Type);

-- 对 Object:CreateClass 里面的局部空表中，声明一个新的字段，并不会修改到 Object.Type 字段，改的都是 object 接受到的对象
object.Type = "Object";
object:Test();

-- 面向对象 继承
function Object:SubClass(className)
    _G[className] = {};
    local obj = _G[className];
    self.__index = self;
    obj.Base = self;
    setmetatable(obj, self);
end

Object:SubClass("Person");
local tempPerson = Person:CreateClass();
tempPerson.Type = "Person";
tempPerson:Test();
print(tempPerson.Type);

Object:SubClass("Enemy");
local tempEnemy = Enemy:CreateClass();
tempEnemy:Test();
print(tempEnemy.Type);

-- 面向对象 多态
-- 相同行为，不同对象，就是多态
-- 相同方法，不同执行逻辑，就是多态
Object:SubClass("GameObject");
GameObject.x = 0;
GameObject.y = 0;
GameObject.z = 0;
function GameObject:Move()
    self.x = self.x + 1;
    self.y = self.y + 1;
    self.z = self.z + 1;
    print(self.x);
    print(self.y);
    print(self.z);
end
GameObject:SubClass("Role");

-- 实现多态重写 Role 类的 Move 方法
function Role:Move()
    -- Base 指的是 GameObject 表（类）
    -- 这种方式调用相当于是把基类表作为第一个参数传入了方法中
    -- 避免把基类表传入到方法中，这样相当于就是公用一张表的属性了
    -- 我们如果要执行父类逻辑，我们不要直接使用冒号调用
    -- 要通过.调用，然后传入第一个参数
    self.Base:Move(self);
end

local Role1 = Role:CreateClass();
Role1:Move();